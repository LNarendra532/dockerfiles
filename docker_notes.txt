Docker command
when you run AMi it is called as a server , server is running instance of AMi

docker ps - will get running instances

docker images - displays local imkages

docker pull <image-name>:<tag/version> ---> get the image
docker pull nginx:9 - pullit from docker hub 
docker pull nginx

docker create nginx - from nginx image -create container

docker ps -a - all containers including all status
docker start <container-ID>

docker rm <container-ID> - remove container
docker rm -f <container-ID> - forcely remove

docker rmi <image-name or id>  - it will removes the image


docker run nginx - docker run pull the image,run the container,start the container
docker run <image>:<tag> -> docker run pull the image + run the container + start the container - it will run foreground
docker run -d nginx - it will run background  -d detach mode

0-65,535 -> container is like a mini server 0-65,535 ports are available .
nginx port number listen on -port  80 - container port
requset will come to host port

docker run -d -p [host-port]80:80[container-port]
http://<ip-address>  - check in browser

host-port should be unique : we cannot use already used port while creating a container
cannot reuse already used host-port.

docker ps -a -q - list out all the container ids
docker rm -f `docker ps -a -q` - remove all the containers at a time

docker run -d -p 80:80 -name nginx nginx - name should be unique we canot reuse again

docker exec -it <contailer-name/contailer-ID>
docker exec -it nginx bash - contailer login command

cat /etc/nginx/nginx.conf

docker inspect <contailer-name/contailer-ID>
docker inspect nginx - we can get contailer-information

docker logs <contailer-name/contailer-ID> to check logs
docker logs nginx


How can you create cusotm images to your application

Dockerfile ---> a set of instrucionts to create cusotmised images


https://docs.docker.com/reference/dockerfile/  - Docker reference 	


Dockerfile - Instrucitons

FROM
=====
 FROM is the first instrucionts of the Dockerfile
FROM almalinux:9     = almalinux which is equivalent -> rhel

without verion it will take latest

How to BUILD
------

docker build -t <image-name:version> . -> -t means - tag

[ docker build -t from:v1 . ] --> [. means current dir] has Dockerfile
docker build -t from:v1 dockerfile-path

docker images - to check/list out the images


RUN 
===============
on base images we can install required  packages/ configurations 
RUN executes at time of image creation

RUN dnf install nginx-y

How to BUILD
------

docker build -t run:v1 .  - 

CMD
=============
CMD executes at the time of container creation i.e at the time of docker run. 
there should be only one CMD instruction inside Dockerfile

in contaners there is no kernel 

system start nginx --> /etc/systemd/syste/nginx.service

nginx run container command
["nginx" "-g" deamon off;"] - it will run nginx continuosly
-g - means set global congiration directives

INTERVIEW - diffrence between RUN vs CMD

FROM run:v1
CMD ["nginx" ,"-g", deamon off;"] run in foreground

cmd should only one cmd instruciont inside dockerfile-path
if we give many CMD instructions it will take last CMD instruction

COPY
=========
copies the code from local to container

RUN rm -rf  /usr/share/nginx/html/index.html #it will alredy index.html
COPY index.html /usr/share/nginx/html/index.html

[ docker build -t copy:v1 . ]
docker run -d -p 80:80 --name copy copy:v1
dcoker ps

ADD
=========
COPY and ADD both copies the code from local to container. 
But ADD command has two more advantages

1. it can directly fetch the file from internet
2. it can directly untar the file into the  container

docker exec -it bash - login to <imagename_/container-ID> container


docker rm add  # previous one removing
docker build -t add:v1
docker run -d -p 80:80 --name add add:v1



#################


docker push docker.io/joindevops/label:v1

ENTRYPOINT
=============
CMD instruction can be overriden
We can't override ENTRYPOINT, if we try to do it will override
We can use combination of CMD and ENTRYPOINT for better results, ENTRYPOINT will have command, default args can be supplied by CMD
You can always override default args through command line

ping google.com ping facebook.com

ARG
=======
ARG is build time variables, they can't be accessed inside container. ENV can be accessed build time and then inside container also
ARG instruction variables can be overriden

in an exceptional case ARG can be the first instruction to supply version to base OS in FROM, you cant use that version after FROM instruction

How can you use ARG inside container?

ONBUILD
========
While devloping images you can put some conditions while others are using your images...



########################


session 54

docker network ls
docker network create roboshop

catalogue depends on mongodb 
cart depends on catalogue

docker -u login lvnaren532
for i in catalogue mangodb mysql shipping user ; do cd $i;docker build -t lvnaren532/$i:v1 ; docker push lvnare532/$i:v1 cd ..;done

#docker compose 
 docker compose command line tool where you can we define  container as services.
 TO manage mutli container application we can define all the containers as services, 
 create dependencies between them , satrt them at once , stop them at once
 
 
 
 Main Uses of Docker Compose:
Define Multi-Container Applications

You can define all your services (e.g., app, database, cache) in a single docker-compose.yml file.

Example:

yaml
Copy
Edit
version: '3'
services:
  web:
    image: myapp
    ports:
      - "8080:80"
  db:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: root
Easier to Start/Stop All Services

Single command to start everything:


docker-compose up
Single command to stop everything:

docker-compose down
Shared Network by Default

All services in a docker-compose file are automatically 
connected on the same network, making service-to-service communication easier.

Example: Your web service can connect to db with hostname db.

Environment Management

You can set environment variables, volumes, networks easily inside the docker-compose.yml.

Local Development & Testing environments

Ideal for setting up development environments, CI/CD pipelines, 
or testing environments without deploying to production.

#####
#########################


Alll our continers  going to be services

#static/ means copy including files and folders
# static/* it will copy only files

IMPOERTANT:
# if we any changes in dockerfile - we have to rebuild  the image - if it is alredy created

docker build -t  lvnaren532/frontend:v1 --no-cache .

delteing schema.sql beacuse of the delting alredy existing one because of the order 
we can tell this situation in insterview

container are ephemeral - temporay by default containers
if we remove them it remove the data

###############55 SESSION ###############

for i in $(ls -d */); do  cd $i ; name=$(basename "$i"); docker build -t lvnaren532/$name:v1 . ; dockerpush /lvnaren532/$name:v1 ; cd .. ; done


for i in $(ls -d */); do

    This loops over all directories (*/) in the current directory

    Example: If you have folders: app1/, app2/, it will run the loop once for each

cd $i

    Enters the directory (e.g., cd app1)

name=$(basename "$i")

    Extracts just the folder name without trailing slash

    Example: app1/ → app1

docker build -t lvnaren532/$name:v1 .

    Builds a Docker image from the Dockerfile in the current directory

    Tags it as: lvnaren532/app1:v1 (for example)

        lvnaren532: Docker Hub username

        $name: the folder name

        v1: image version

dockerpush /lvnaren532/$name:v1

    ❌ This is likely a typo

    ✅ Should be:

    docker push lvnaren532/$name:v1

    Pushes the built Docker image to Docker Hub

cd ..

    Goes back to the parent directory and continues the loop



	
##########

OPtimization 

1.images sie is big
	use minimal version
	alpine version
	
imp : while doing optimizaion - After  reduce size of the image -user has to login  / should load the application / then it is success

after reducing the image size above thisng should happen other wise it is a big mistake

########

-v host-dir:contaner-dir:
/usr/share/nginx/html/  --> ngnx html dir
if we delete container - host having the data 

volumes 
un-named volumes /unmanaged volumes 
if we create dir and manage it then those un-named/un-named volumes
if docker creates volumes adn manages them then they are named/manages volumes

where data is important is called statefull application ..
app code is stateless..
end user data store place mysql.rabbitmq,redis etc.. statefull

webtier config files , application code  stateless

where we need to create volumes ---

volumes should be created to statefull application . data bses store the actula data is host directories
while rendering for users it will show tables or collections

every datat-base store the data in ---- in some place/directroy in a server


/my/own/datadir:/data/db -d mongo
$ docker run --name some-mongo -v /my/own/datadir:/data/db -d mongo

how to create named volumes
docker volume create nginx
docker volume ls 
docker inspect nginx

docker run -d -v nginx:/usr/share/nginx/html -p 80:80 nginx

docker exec -it continer-id bash
cd /usr/share/nginx/html/
echo "hello html cainer volume" > helllo.html
rm -rf contaner-id
data will be available in nginx volumes

docker compose up -d
docker compose down - application will delete

docker rmi `docker images -a -q` remove all images

system user creation -run it as normal user

RUN addgroup -S roboshop && adduser -S roboshop -G roboshop

✅ Explanation:

    addgroup -S roboshop:
    Creates a system group named roboshop
    -S means "system group" — meant for service/system users.

    adduser -S roboshop -G roboshop:
    Creates a system user named roboshop and assigns it to the group roboshop.

 

	docker exec -it catalogue sh - is for alpine images
- use minimal images
-use official images
-run it as non root containers
-multi stage builds
- optimize layers

after running command - installing softwares we have some data - data is cached
we have to remove using multi stage builds

# multi stage builsds
# we can use msb builds , multiple dockerfiles inside single docker files
# we can use one as builder another one final image.we can copy files in builder image paste it to the final image 
# we can save some space 

-multi stage builds are like keeping Multiple Dockerfiles in a single Dockergile. one Dockerfile we can use it as builder,
another Dockerfile we can use it as final image, we can copy what we want form builder to final image
this reduce memeory and then unnecessary installations.

optimize layers
-------------------
docker builds -t lvnaren532/catalogue:v1 --progress=plain --no-cache .

DOCKER_BUILDKIT=0 docker build -t joindevops/user:v1 --progress=plain  .
output will come

frequently changing docker instrucitons we need to keep it to at the end docker-file 
so that previous layers will not be disturbed

Combine multiple RUN commands into a single instruction to 
reduce the number of layers in the image



















 














